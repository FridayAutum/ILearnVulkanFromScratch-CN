## 次级指令缓冲

Secondary Command Buffer

在传统的指令缓冲，又称 Primary Command Buffer 中，我们在录制 Command Buffer 的时候需要在开始时指定一个 Render Pass 和 Framebuffer，录制时开始一个 Render Pass，然后顺序的提交我们的指令（所有指令类型可以在概念汇总的“指令缓冲”一章中找到）。这种执行流程在场景没有大改变，指令缓冲不用每一帧改变时没有问题，但是在遇到大型的图形应用程序中，以下几点会受到这套流程的限制：

* 指令缓冲中的绘制命令会随着时间变化而变化，这在大型图形应用程序和游戏中都格外普遍。同时，在这种规模的项目中一个指令缓冲会有大量的绘图指令隶属于同一个逻辑上的用途（例如绘制菜单、HUD、一个场景中的 Skybox 等），在指令缓冲变化时这些成批的指令会一起被使用/禁用掉而不会去单独开关其中一条。如果没有一个分组的机制，将这些同一个用途的、固定不变的指令打包起来，录制指令缓冲时只需一条命令就**重用**打包命令的话，每次重新录制指令缓冲时录制过程必定非常繁琐，浪费 CPU 性能。

  我们可以用多个指令缓冲按顺序提交（并显式控制同步）。但首先，所有绘图系指令（`vkCmdDraw`）都需要在一个 Render Pass 上下文中（`vkCmdBeginRenderPass` 和 `vkCmdEndRenderPass`），导致不同缓冲必定在开始会指定一系列的 Render Pass，执行完后结束掉这个 Render Pass，这种方法在有些硬件上是一笔明显的性能开销，并不可取。

* 在运行时（在 render loop 中，而不是准备阶段）动态录制指令缓冲是一件比较吃 CPU 单核性能的事情，因为所有的录制都是顺序执行的。如果我们能将场景中独立的几个部分用**多线程**分别录制命令到某个位置，再在主线程录制指令缓冲时引用这些位置，则可以利用起多核心，避免一核有难 N-1 核围观的境遇，即使每一个指令缓冲都需要在每帧单独更新，例如在做 CPU 遮挡剔除和视锥体剔除时。

于是 Vulkan（和一系列现代图形 API，例如 DirectX 12）引入了次级指令缓冲来解决这些问题。次级指令缓冲同样可以存放指令，就像一个存放有诸多文件的文件夹，能够被主指令缓冲使用 `vkCmdExecuteCommands` 调用其中的指令，甚至同时调用多个次级指令缓冲中的指令。在次级指令缓冲中录制的命令完全与 Render Pass 和 Framebuffer 无关，录制绘制命令时不用再显式调用这些内容（例如 `vkCmdBeginRenderPass`），而这些内容都是在这些次级指令缓冲准备阶段的 `VkCommandBufferBeginInfo` 中指定一个 `VkCommandBufferInheritanceInfo` 类型成员来完成，即实现**继承**主指令缓冲绑定的 Render Pass 和 Framebuffer，以及一系列查询参数（见后续章节）。这个继承成员可以在录制主缓冲时通过函参传给录制次级缓冲的方法，从而使次级缓冲的创建工作可以做到对 Render Pass 的全透明。

![intro commandbuffers](../Vulkan 进阶/次级指令缓冲和多线程录制/Vulkan 学习笔记.assets/vulkan_intro_commandbuffers.png)



## 多线程指令缓冲录制

在该案例中我们将要结合上客户端多线程、次级指令缓冲和 CPU 视锥体剔除来演示如何多线程录制指令缓冲。我们将绘制512个独立运动的物体（这里为了体现多线程绘制不使用实例化渲染），加上天空和和 UI overlay。一个物体对应一个次级指令缓冲，每个物体的次级指令缓冲在录制之前会判断其是否可见，若不可见则不录制（即物体的次级指令缓冲为空）。一个线程对应几个物体，即一个线程负责录制这几个物体的次级指令缓冲。

该案例使用的多线程上下文创建后生命周期直到程序结束。每一个线程可以使用一个方法来推送一个 job 到线程调度器中被该线程执行，该 job 类型为 `void()`（即使用 `std::function<void()>` 传递 job 方法，此处直接传递 lambda 表达式）。存放这些线程的线程池提供 `wait()` 原语，阻塞直到所有线程结束任务的执行。多线程方法细节此处不予讨论。

首先看一下总体流程：

* 准备多线程绘制所需要的资源：
  * 全局一个的主指令缓冲。由于这里主指令缓冲每一个 draw loop 都需要重新构建，所以此处不像之前静态指令缓冲一样每一个 framebuffer（swap chain image）一个了。
  * 多个线程，其中每一个线程分配几个物体的渲染指令录制工作。每一个线程的具体准备如下：
    * 一个 secondary command buffer 的缓冲池。这里使用 `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` 的 flag，因为我们会重复利用这些指令缓冲，并且向让每次提交指令缓冲时将其中的指令清空。
    * 每个物体一个次级指令缓冲。在创建缓冲时 `level` 需要指定为 `VK_COMMAND_BUFFER_LEVEL_SECONDARY`。
    * 准备每个物体的 push constants。该案例中 MVP 矩阵均通过 push constants 传入流水线。
    * 客户端每个物体的属性，例如旋转速度，以及物体经过视锥体剔除计算后的可见性布尔值。
    * 客户端多线程有关配置，此处省略。
  * 一个专门负责天空盒和 UI overlay 渲染的次级指令缓冲。
* 准备其它准备内容。
* 在每个 render loop，开始录制主指令缓冲：
  * 创建一个存放次级指令缓冲的数组 `std::vector<VkCommandBuffer> commandBuffers`；
  * 在 begin info 中绑定 Render Pass 等信息，开始录制；
  * 设置 `VkCommandBufferInheritanceInfo`，填入使用的 Render Pass 和 Framebuffer；
  * 将继承信息作为参数，执行更新天空盒的次级指令缓冲并添加到上述数组中；
  * 对每个线程添加 N 个 job，其中 N 为每个线程负责绘制物体的个数。线程 job 方法将当前线程/物体 id 和继承信息传入一个方法：
    * 检查物体位置是否在视锥体内，若不在的话标记该物体可见性布尔值为 False，并直接 `return`。
    * （若可见）对于每个物体，使用继承信息开始录制对应的次级指令缓冲，即正常流程的 binding 和 `vkCmdDraw`。
  * 阻塞并等待线程池所有线程执行完毕；
  * 查看每个线程的每个物体是否可见，若可见则将其次级缓冲添加到上述数组中；
  * 将继承信息作为参数，执行更新 UI overlay 的次级指令缓冲并添加到上述数组中；
  * 调用 `vkCmdExecuteCommands`，传入上述数组的大小和 `data()`。主指令缓冲中没有任何绘制命令，所有绘制命令都存在于数组中的次级指令缓冲中。次级指令缓冲按照数组中的排列**顺序执行**。

这个案例很好的演示了次级指令缓冲和多线程配合使用的情景。需要注意的是，在实际流程中可能不会给每一个 Mesh 配备一个次级指令缓冲，而是给每一个“指令基本不变，只会同时有效/无效”的物体配备次级指令缓冲；或完全将次级指令缓冲当成一个线程资源，一个线程对应一个次级指令缓冲并独立更新，之后将这些缓冲 reduce 到数组中供主指令缓冲更新，但是要注意，Vulkan API 不提供“Tertiary Command Buffer”，所以每一个次级指令缓冲的用途要好好衡量一番。当然，如果能使用实例化渲染时当然也要首先考虑实例化渲染，其性能比多线程指令缓冲的录制要更好一级。

