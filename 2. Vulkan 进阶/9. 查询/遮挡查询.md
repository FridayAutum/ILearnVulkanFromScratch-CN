## 遮挡查询

在查询范围内，使用遮挡查询可以获得绘图指令中通过测试的片元的个数计数器。计数器初值为 0，片元的所有部分（这里指的是多重采样）若通过了所有测试（scissor，sample mask，alpha to coverage，stencil，depth），即将计数器 + 1。遮挡查询只能在图形队列中使用。

但需要注意的是，即使一个片元通过了所有的测试，但也有可能被后绘制的物体覆盖导致“被遮挡”，**做不到完全的遮挡测试**，在前向渲染时也只能做到有限的遮挡剔除。若想实现遮挡测试，必须将遮挡物体在判断是否遮挡的物体之前绘制。

同时，由于查询的结果不可能在查询所对应的绘制命令之前得出，因此查询结果只能够给予后面的流程一个参考，即一个未来预测器。

其典型的用途为（其实下面两个用途原理上是一个）：

* GPU 视锥体剔除：由于在视锥体完全在外面的物体不会有任何片元通过测试，因此将未通过测试的物体在之后不予绘制，则可以做到 GPU 判定的视锥体剔除，当然结合上 Compute Shader 可以做到完全的 GPU 视锥体剔除（之后会谈到）。

  不过，由于上述提到的时间差异，有些本不应该被剔除的物体由于之前处于视口外而被判定为剔除，从而在画面中消失，这种情况在视角**超大范围转动**，或查询的绘图比较多从而导致时间长时比较明显，但一般情况下只要物体在视锥体内一点点就不会被剔除，稍微大一点的视角晃动不会经常导致一个物体从完全不可见到完全可见，所以这种 artifact 的发生比较极端，即使发生也不会太明显。同时，使用这种方法在视锥体内的有些物体也会被剔除（这就完全是下述的遮挡剔除了），若视角**大范围移动**时，由于时间差异可能会出现某物体后当前应该可见的物体在之前不可见（被遮挡），从而在画面中消失。

  视锥体剔除技术虽然是万金油，但是其效用根据场景类型而定。如果场景不存在很多处于视锥体外的物体则查询花费的时间多于执行这些物体顶点变换和测试的时间（视锥体外的物体本来也不会 Invoke Fragment Shader），适得其反。

* 遮挡剔除：前面已经提到了，使用遮挡查询进行遮挡剔除是比较受限的。但虽然受限，在遮挡发生很频繁，而客户端有没有能力每帧都为物体排序的情况下，使用遮挡剔除仍然能够减少不少片元检测之前的工作量的。如果使用上述视锥体剔除，其实也同样在做遮挡剔除了，反之同样生效。当然，若还想省下 Fragment Shader 的计算，则采用第一个 pass 只渲染深度缓冲，在第二个 pass 在正常渲染场景的方法，或是其加强版——延迟着色即可。同样，如果遮挡不频繁使用遮挡剔除也会适得其反。

参考资料：https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter06.html

查询完毕后，返回结果为一系列 `uint32` 或 `uint64` 数组（根据是否设定 `64_BIT` 而定），每个数组元素代表对应查询条目的通过测试的片元数。当指定 `VK_QUERY_CONTROL_PRECISE_BIT` 时，遮挡查询的返回值时精确的，前提条件是 `occlusionQueryPrecise` 设备特性需打开。

在 Sascha 的案例中，我们使用一个平面遮挡两个物体的绘制（在平面的一前一后），当前一帧某物体通过的片元数为 0，则将其 UBO 中的一个代表是否可见的变量设为不可见，在下一帧 Shader 中根据这个变量决定是否进行光照着色。

