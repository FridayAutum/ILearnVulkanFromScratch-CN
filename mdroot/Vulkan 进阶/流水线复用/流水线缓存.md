# 流水线缓存 (Pipeline Cache)



### 介绍

在 **Vulkan 基础/图形流水线** 一章提到过，由于创建/编译流水线是一个很费时的工作，因此我们想把编译好的流水线缓存下来，在下一次启动程序时直接加载流水线缓存，跳过耗时的编译工作。

> 这个概念即对应着各个游戏引擎 / API 抽象层的 **PSO (Pipeline State Object)** 概念。由于第一次在目标平台执行程序时编译 Shader 等耗时操作几乎不可避免，因此在程序加载时预先编译好流水线，之后启动程序直接用（平台相关的）缓存即可。
>
> 我们可以在程序/游戏的测试期间在场景中闲逛，并且监听创建流水线的操作并记录下来其对应的材质，之后汇总成一张列表。下一次在新的设备开程序/游戏时，直接在加载界面把这张列表中提到的流水线预编译并缓存好，尽可能避免运行时的卡顿。例如 Unreal Engine 4 中的[PSO缓存机制](https://docs.unrealengine.com/4.27/zh-CN/SharingAndReleasing/PSOCaching/)。
>
> DX12，Vulkan 和 Metal 都提供了原生的 PSO 支持，OpenGL 只能做到缓存 GLSL 的字节码到本地。



### 使用流程

#### 生成空缓存对象

首先，使用 `vkCreatePipelineCache` 方法，生成一个**空的** Pipeline Cache 对象 `VkPipelineCache pipelineCache` ：

```cpp
VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);
```

> `VkPipelineCache` 同样也只是一个句柄。

其中，对于 `pCreateInfo` 来说，我们需要填写 `VkPipelineCacheCreateInfo`：

* `flags`：其当前只会决定多线程环境下，使用这个 Pipeline Cache 对象需不需要驱动内部做同步操作。
* `initialDataSize`：由于我们第一次创建缓存对象，因此留空，即填写为 0。
* `pInitialData`：同理，设为 `nullptr`。

```cpp
typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;
```



#### 首次创建 Pipeline

然后，使用我们熟悉的 `vkCreateGraphicsPipelines` 函数来首次生成 Pipeline：

* `pipelineCache`：填入上面步骤中初始化的 `VkPipelineCache pipelineCache` 

```cpp
VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,   // !
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
```

在调用完毕后，`pipelineCache` 即可被使用。



#### 获取缓存数据

使用 `vkGetPipelineCacheData` 获取 `pipelineCache` 的具体数据到本地：

```cpp
VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);
```

同理，我们可以先调用该方法，但 `pData` 留空来获取缓存数据的大小，然后以此 new 一片内存（或数组），再调用该方法获取到具体的缓存数据。

拿到缓存数据后，我们可以选择将其**序列化到硬盘上**。

> 当然，为了知道这个缓存对应的流水线状态，也需要同时将流水线创建的状态信息 Hash 下来，创建一个 [状态信息: 流水线缓存] 的 HashMap。下次创建流水线时，先判断其状态 Hash 值是否存在于该 HashMap 中，若存在则直接用缓存。



#### 读取缓存数据到缓存对象

（可能时下一次打开程序时）再次使用 `vkCreatePipelineCache` 方法创建出 Pipeline Cache 对象 `VkPipelineCache pipelineCache`。当然，这次创建时，`VkPipelineCacheCreateInfo` 中的 `initialDataSize` 和 `pInitialData` 将使用之前的缓存数据。



#### 使用缓存创建 Pipeline

再度使用 `vkCreateGraphicsPipelines` 并指定 `pipelineCache` 后，创建流程将**可能会用流水线缓存加速流水线的编译创建工作**。

如果





```cpp
typedef struct VkPipelineCacheHeaderVersionOne {
    uint32_t                        headerSize;
    VkPipelineCacheHeaderVersion    headerVersion;
    uint32_t                        vendorID;
    uint32_t                        deviceID;
    uint8_t                         pipelineCacheUUID[VK_UUID_SIZE];
} VkPipelineCacheHeaderVersionOne;
```

