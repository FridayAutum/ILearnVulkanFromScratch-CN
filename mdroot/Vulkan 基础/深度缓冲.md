## 深度缓冲

如果仅仅按照上述方法进行绘制的时候，在顶点列表或索引列表（看你用谁了）中排序靠前的顶点将会先绘制，靠后的将后绘制，并将覆盖到之前绘制的内容上，即使靠后的内容在三维空间中被靠前的内容覆盖住，造成透视异常。当然，在绘制不同物体时，后绘制的物体不论其在空间的远处还是近处，都会覆盖在先绘制的物体之前。

有两种方法解决这个问题：首先可以手动将空间中远处的顶点先绘制，然后再绘制近的，这种方法常用于绘制半透明物体（因为半透明物体并不是遮挡，而是颜色混合）但这样做在面对复杂不透明模型的大型应用程序的时候显然时不适用的（题外话：PlayStation 1 的图形硬件就并不支持 Depth Buffer，因此饱受开发者诟病，因为开发者需要在 CPU 端排序顶点和背面剔除），所以这里将光栅化后像素的深度也考虑在内，其首要目的就是为了解决遮挡。

一个深度缓冲是一个额外的 attachment ，记录着像素的深度信息。当每一个面被光栅化之后，在执行 fragment shader 之前，将会先进行深度测试（属于前期片元测试  Early Fragment Test 环节），对比一个即将渲染（即触发 fragment shader）的片元的深度和深度缓冲中同位置的深度，如果深说明被遮挡，则舍弃 discard 掉，即不参与之后的渲染工作；如果不深则可以进行后续渲染工作。

**深度缓冲是个完完全全的工具类纹理，其将会自动被关联的 subpass 进行深度测试读取和写入，正常情况下客户端程序和 shader 均不能对其进行写操作。片元深度值可以直接通过 Fragment Shader 中的 `gl_FragPos.z` 值获得，若想保存深度值供后续处理（例如 G-buffer） ，则可以将其写到某个 color attachment 的某个分量中（比如 a），或是作为一个 image attachment；若想手动写入深度值，可以在 shader 中直接写入内置变量 `gl_FragDepth`，但这样做效率很低，并且会使得提前深度测试失效。**

依照这种原理，我们可以得到两种实现：

* 在一个pass中搞定绘制。对于每一个来到深度测试环节的片元，比较当前同位置的深度缓冲的值和自己深度值，如果深一些则表示当前有更靠前的片元了，于是舍弃；若浅一些就直接绘制上去。这种方法只需要一个pass就行，节省带宽和资源，但是假设顶点顺序恰好是由后到前的（最坏情况），就会出现片元覆盖，导致覆盖了的片元着色器结果作废，一定程度上也造成了资源的浪费。

* 在两个pass中实现。首先，在第一个 pass 中（Depth Pre-Pass）使用一个最简单的 vertex shader 只进行坐标变换，不使用 fragment shader（这是可以的）。接下来再第二个pass中进行真正的图像渲染（传统的前向渲染和延迟渲染都可以利用上 Depth Pre-Pass），再流水线来到测试环节时，比深度缓冲深的像素一律作废，只有小于等于深度缓冲的内容才会被渲染，如果实际渲染的 fragment shader 计算重的话，使用这种“记录中间值”的方法可以极大程度的提高渲染效率，当然也要考虑到两个pass和之间的 attachment（还是习惯性叫做 render target）所占用的布局变换性能和带宽损失。

  有时候，Depth Pre-pass 不需要渲染全部几何体，只需要渲染占地比较大，能够产生明显遮挡的集合体，比如房屋的骨架、墙面、地面等，因为如果在 Depth Pre-pass 中细致的渲染每一个复杂的多边形（例如使用 Alpha Cutoff 的植被），其花费的时间可能要比在之后节省的时间多，从而得不偿失，尤其在使用延迟着色时。也有时候，移动设备的 TBR 特性会导致 Depth Prepass 反而成为负担，在此种设备上需要谨慎考虑使用 prepass 的性能。

该案例使用第一种比较简单粗暴的方法。


