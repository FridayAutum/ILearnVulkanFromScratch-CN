## 帧缓冲 (Framebuffer)

**原文：https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers**

流程方法名：`createFramebuffers()`

---

## 介绍

**帧缓冲 (Framebuffer) 为一组 Render Targets 的集合，并且其也和 Render Pass 绑定，作为其输出的目标位置。**

此处 Framebuffer 和 Swap Chain 中的 image 格式相同，引用着所有的 Attachments 中的`VkImageView`（在本教程中只有一个颜色 attachment）。Swap Chain 有多少个 Image 就要有多少个对应的帧缓冲，即此处 Swap Chain Image 与 Framebuffer 一一对应。

因此需要一个数组来盛放所有我们需要的 Framebuffer：`std::vector<VkFramebuffer> swapChainFramebuffers`，并且resize 成 Swap Chain 中 image 的数量。

对于每一个 Swap Chain Image，都需要对其包装一个`VkFramebufferCreateInfo `创建信息，其中需要：

* 之前声明的`renderPass`，这意味着 Framebuffer 和 Render Pass 需要兼容，例如图像格式和数量都和 attachments 相同。
* `attachmentCount`和`pAttachments`：绑定和 Render Pass 里 Attachments Description 相同的`VkImageView`，本案例中直接用对应 Swap Chain 里面的`VkImageView`。
* `width` `height` `layers`即为SwapChain对应长宽和层数（此处为1层）。

使用`vkCreateFramebuffer`创建帧缓冲，在cleanup阶段使用`vkDestroyFramebuffer(device, framebuffer, nullptr)`销毁。



## 代码实现

```cpp
// private member variable
std::vector<VkFramebuffer> swapChainFramebuffers;

void createFramebuffers() {
    
    swapChainFramebuffers.resize(swapChainImageViews.size());

    for (size_t i = 0; i < swapChainImageViews.size(); i++) {
        
        // we need two attachments: color (using swap chain image directly), depth
        std::array<VkImageView, 2> attachments = {
            swapChainImageViews[i],
            depthImageView
        };

        // fill create info
        VkFramebufferCreateInfo framebufferInfo = {};
        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferInfo.renderPass = renderPass;
        framebufferInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
        framebufferInfo.pAttachments = attachments.data();
        framebufferInfo.width = swapChainExtent.width;
        framebufferInfo.height = swapChainExtent.height;
        framebufferInfo.layers = 1;

        // create!
        if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) {
            throw std::runtime_error("failed to create framebuffer!");
        }
    }
}
```

