# 基于物理的着色

基于物理的着色这里当前打算分为如下几个部分（估计得写一阵子了）：

* 什么是基于物理的着色 PBR，包括什么是渲染方程，直接光 / 间接光 / 全局光照（GI）都代表着什么，BRDF 以及其组成部分等；
* 实时渲染中直接光最"直接“的处理方法；
* 怎么拟合出间接光：基于图像的照明 IBL、球谐函数 Sphere Harmonic 等；
* 环境光遮蔽的处理方法，Bent Normal；
* 拓展出来的不同 BRDF 模型：次表面反射（皮肤）、各向异性等等等等。

这里原理部分资料和图像都来自 LearnOpenGL 的 PBR 章节 https://learnopengl.com/PBR/Theory，其余知识点主要参考自 Real-time Rendering 一书和 UE4 / Unity 引擎的 Shader 源码。

当然，因为 BRDF 涉及大量的基本概念和数学运算，如果完全记录在这里实在没有必要，所以这里只记录一些最最简单的，最感性的，最通俗的，最好理解的内容，让这些知识点变成一个 Hashtable 的键值存在脑子里，如果工程里面真的要去用了也可以快速用这些感性的概念去 Google 想要的具体实现和公式推导，而不至于一头雾水。

同时，因为在现代的图形应用中，你如果选择了要使用 PBR，材质、灯光（包括光线追踪）、摄像机等等场景部件的处理也必须统统基于物理，而我又不能把这些东西全放在这个章节下，所以很多满足基于物理的概念去做的事情我就放在其它章节了，这个章节专心记录 PBR 本身和其最直接的应用。













所有光照模型可能需要的参数一览：

```c++
vec3 lightPos;		// 世界空间光源位置
vec3 lightColor;	// 光源颜色
vec3 objectColor;	// 物体片元颜色（albedo）
vec3 normal;		// 世界空间法向量
vec3 fragPos;		// 世界空间片元位置
vec3 viewPos;		// 世界空间观察者位置

// 由此可以计算...

vec3 normal_n = normalize(normal);					// 归一化法线		
vec3 lightDir_n = normalize(lightPos - fragPos); 	// 归一化片元->光源方向
vec3 viewDir_n = normalize(viewPos - fragPos);		// 归一化片元->观察者位置方向
```

可能需要使用的变换矩阵：

```c++
mat4 model;			// 模型->世界空间变换矩阵
mat4 view;			// 世界->观察空间变换矩阵
mat4 proj;			// 观察->裁剪空间变换矩阵
mat4 modelIT;		// 模型->世界空间变换矩阵的逆转置矩阵，即法线矩阵
```

注意，下面所有光照计算均发生在世界空间，虽然在观察空间可以免掉观察者位置（恒为原点），但在世界空间中理解较为直观。由于光源方向已经将片元位置和光源位置关联起来，因此这里光照模型和光源类型（平行光、点光源、探照灯等）并没有关系。

