# 交换链 Swap Chain

交换链为一套与显示设备vblank（vertical blanking，此时显示器完成了所有像素的刷新，在等待下一次刷新全部像素）同步，向显示器输出渲染帧的机制。这里的同步机制称为交换（swap），交换时机即为vblank发生时。

交换链的显示模式有三种。第一种即只用一个 framebuffer，渲染操作直接渲染到该缓冲，显示器刷新到来时直接从缓冲中取出这张图像并显示，俗称“立即渲染”（在Vulkan中对应`VK_PRESENT_MODE_IMMEDIATE_KHR`）。由于显示和渲染是并行执行的，存在渲染未完成时就被显示器取走了，导致取走的图像中一半是之前的结果，一半是这次未完全渲染的结果，导致“图像撕裂”。渲染频率大于或小于vblank频率都会造成撕裂。

在双重缓冲（`VK_PRESENT_MODE_FIFO_KHR`）中，包含两个 framebuffer：前台缓冲 front buffer 和后台缓冲 back buffer，渲染操作渲染到后台缓冲，而前台缓冲负责在每个刷新到来时向显示器提供图像。当后台缓冲的渲染流程完全结束时并等来了vblank，将两个缓冲进行交换（swap）。这样即使刷新和渲染没有匹配，显示器拿走的永远是渲染好的一张图，实现了垂直同步（vsync）。其实，本质上这个交换操作并没有互换两个缓冲区的内容，只是调换了指向两片缓冲区域的指针，并没有多余的性能消耗。但在使用双重缓冲时，如果渲染速度较vblank快，在等待vblank到来时其实并没有地方继续渲染新的像素，整个渲染就停止了，导致显示器再拿到下一帧画面时距离这帧画面渲染好可能已经过了一段时间，造成用户可感知的延迟。在客户端代码中，这种“停止”反应为向交换链提交时的**阻塞**操作，具体阻塞方法为`vkQueuePresentKHR`。

当然，这里还提供了一种方法，如果渲染速度比较慢，导致一次vblank来的时候没渲染完，交换链会立刻把没渲染完的画面也交出去（跟考试到时间交卷子一样，做的快就等着，做的慢到时间也得交了），在Vulkan中叫做`VK_PRESENT_MODE_FIFO_RELAXED_KHR`。

为了让在等待的同时也继续渲染“新鲜的”帧，可以将后台缓冲也设为两个，渲染完一个以后若vblank还没来就继续渲染第二个，以此类推。当vblank来了的时候，将这两个里面完成渲染的那一个和前台缓冲区进行交换，保证这一帧的新鲜性和完整性，充分利用了硬件性能，降低了延迟。这种机制叫三重缓冲（`VK_PRESENT_MODE_MAILBOX_KHR`）。

在使用立即渲染和三重缓冲时，渲染将不停歇执行，充分利用设备性能，但可能造成渲染结果的浪费，这时候如果要限制帧率（比如在60Hz刷新率的系统限制到120Hz的渲染频率也能有效的减少输入延迟）需要在客户端中手动实现。而在使用双重缓冲时，其等待机制已经限制了渲染的频率，即渲染频率不可能比显示频率高。

上述实现Vulkan将会自动结合着设备驱动实现，客户端中只需要指定交换链类型即可。在那些离线渲染，或者根本和图形不搭边的应用（通用计算）中没有必要声明交换链。

//TODO: 为什么要针对每个交换链的 Image 声明 Framebuffer 并每次渲染时渲染到不同的 Image 上？

