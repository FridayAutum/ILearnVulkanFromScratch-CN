# 队列 Queue

对于客户端，队列即 command buffer 提交的渠道；对于 Vulkan，队列即其向一个设备驱动程序发送特定命令的渠道，驱动会将这些整合发到硬件队列中。对于GPU来说，其只能看到从队列里一条一条流过来的指令，而这些指令并没有所谓 command buffer 来打包它们。

可以将队列理解为一个下水道（bear me on this），每一个 command buffer 就是一桶污水。在 command buffer 提交的时候就会将里面的污水到在下水道里，下水道负责运送这些脏水到污水处理厂（GPU）内，污水处理厂将会一点一点消化这些污水。

队列中如果不加显式的同步，除了在一个 render pass 中的绘制指令能够保证执行顺序，其他情况下指令没有任何执行顺序可言（计算指令则完全乱序执行）。可以参考**同步**一章。

常见队列类型为：图像渲染队列（可以执行`vkCmdDraw`系列指令）、通用计算队列（可以执行`vkCmdDispatch`系列指令）、转移/拷贝队列（可以执行`vkCmdCopy`系列指令）。注意，显示时涉及到的“显示队列 Present Queue”并非一个队列类型，而是一个特定队列的兼容能力，通常图像渲染队列就兼容显示能力。

一个队列的功能可能能够满足多种队列类型，或者说一个队列可以属于多个队列类型。在旧版本图形 API 中，所有类型的指令都会被顺序放在一个通用的队列中近乎顺序的执行，但 GPU 是个庞大的并行处理硬件，因此这种顺序执行有时候会造成某些硬件部件的浪费。在 Vulkan 中，那个通用的队列依然存在，但同时抽象出了几个有着专门功能，即只属于一个队列类型的队列，负责并行的执行不同的任务，例如同时执行绘图、通用计算和通过 DMA 在 PCI-E 高效传输数据的工作。

属于相同类型的队列的集合被称为队列家族 Queue Family。通常我们通过队列家族取出我们想要的队列。常见的家族和家族中队列数量为（以 GTX 2080Ti 为例）：

| 队列家族编号 |        队列家族         |              队列类型（flags）              | 家族中队列的数量 |
| :----------: | :---------------------: | :-----------------------------------------: | :--------------: |
|      0       | Graphics (Direct) Queue | GRAPHICS, COMPUTE, TRANSFER, SPARSE_BINDING |        16        |
|      1       |  Transfer (Copy) Queue  |                  TRANSFER                   |        1         |
|      2       |      Compute Queue      |                   COMPUTE                   |        8         |

Vulkan 抽象出的队列数量在很多情况下并不等同于硬件的队列数量，因此在创建队列时需要搞清楚目标硬件的具体队列数量，因为创建过多的队列最终也会被安排到一个硬件队列中执行，性能得不到任何提升，并且很可能因为需要进行同步而损失性能。满足 WDDM 的驱动程序会向 Windows 提供具体的硬件队列（当然也是驱动抽象出来的，再往下就不是能看得到的了），可以使用 GPUView 看到每一个队列的执行图表来分析任务是否有效的在不同队列上并行执行，甚至可以通过自带的任务管理器查看 GPU Tabs 中的硬件队列使用情况（此处称为“引擎”）。

但时，由于很多情况下 GPU 暴露出的不同硬件队列所对应的执行单元都是**共享**的，因此一个队列会影响另一个队列，导致其效率跟单独使用一个队列提交各种任务并没有什么区别，同时不同硬件的实现也会导致很大的差别。具体实践可参考 https://gpuopen.com/concurrent-execution-asynchronous-queues/。通常的做法（正像很多在 Windows 平台使用了 DX12 的游戏一样），提供两种解决方案分别对应使用 Async Compute 和不使用，并分别 Benchmark 它们来找到最佳的平衡点。

