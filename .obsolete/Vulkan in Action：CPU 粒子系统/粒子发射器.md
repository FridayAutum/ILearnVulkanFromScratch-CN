## 粒子发射器

### 传参

在该案例中，粒子发射器将直接修改粒子的顶点属性 vertex attribute 缓存，并更新其位置、颜色、alpha、大小、旋转等属性。因此，粒子发射器所使用的 VAO 将不再使用 staging buffer + device only 可见度，而是直接与客户端 coherent 并保持 mapping 状态，每一帧直接对其进行更新。

设计粒子发射器的传值方法其实有很多种思路，这里分别讨论一下：

- （该案例采用的）直接更新 VAO，UBO只存 VP 变换矩阵：最直接，所有值直接通过 `layout(location = x)` 传入 Vertex Shader。并且由于该案例中的粒子仅仅为一个有大小的点 primitive，旋转变换体现为在 Fragment Shader 中采样纹理（见上一章节），并且一个 draw call 即可完成所有绘制工作。
- VAO 仅存一个粒子模型，使用不同的 UBO（或者 Dynamic Uniform Buffer）更新其属性（通过变换矩阵等 uniform 变量），shader 只负责正常变换和采样。这样实现的话，每个粒子都需要一个 draw call。
- 多实例：VAO 仅存一个粒子模型，维护一个大 UBO，使用多实例渲染。draw call 缩减为1，但由于粒子会被回收再利用，UBO 内部顺序需要对应上实例编号，维护相对来说比较麻烦。

### 粒子生命周期和初始化

每个粒子发射器在初始化粒子时都有一个粒子生成区域，这里使用一个圆形区域，每个新的粒子生成时直接在圆形区域中随机其位置。该案例中其余属性完全进行随机初始化。

在每一帧更新时，粒子发射器都将会更新全部粒子的各种属性。由于客户端保留着粒子的所有属性信息，可以在每次更新时检查其生存时间 / 某个属性是否达到阈值来决定是否进行回收。所谓回收本质上就是将其重新初始化。

该案例一上来就初始化了所有粒子，但一般情况下粒子生成器也会控制每个粒子的生成间隔，其对传参的方法也会有影响。

### 宏观粒子发射器

一个粒子发射器也并不一定“发射”可以绘制的物体，其粒子生命周期的概念也可以被用来设置很多抽象物体的属性，例如光源。在该案例中，若仅有火焰和烟雾的纹理在空中飘扬，其效果并不真实，结合上几个同样飘扬的点光源可以将场景塑造的更逼真，当然这种宏观的抽象也会对粒子发射器与流水线之间的传参方法有影响，此处不予讨论。

